/**
 * 非标准响应块：
 * 1. 并行开始(可以接在任何后面？也是一种响应)
 * 2. 并行结束（1. 作为判定节点，决定要不要继续要往下。2. 作为响应节点可能要终结其他并行流程。只能接在有并行开始的响应、事件、后面。）
 *
 * 将响应图生成基于"用户事件、系统事件、定时器" 类型代码的方法：
 * 1. 从起始节点开始遍历，需要记录遍历栈(保存上下文？)
 * 2. 遇到事件节点开始生成"基于事件的代码块(回调形式)"
 * 3. 遍历事件分支
 * 4. 事件分支下遍历系统响应(提供上下文？) 还可能直接遇到"结束"、"并行结束"、"并行开始"？？？
 * 5. 遍历响应块后面
 *   5.1 遇到"分支"，遍历分支
 *   5.2 遇到"并行开始"？？？（其实可以顺序执行到"等待"的地方？不行，未来如果中间没有等待事件也是允许的）
 *   5.3 遇到"并行结束"。进行判定、流程控制、继续往下
 *   5.4 遇到"事件"，"保存上下文、？？？？"，当前代码结束。
 *
 *
 * 1. 用户期望的是事件发生后，后面的响应结果要返回。理论上直到出现新的"等待"事件，之前的代码都算是对前面的响应。
 * 2. 那么遇到"并行开始"节点，该不该启用 await，在一个流程里？评判的标准是什么？
 *
 * 解决域：
 * 1. 框架、原生语言环境都是就 request+回调的结构。
 * 2. 在回调中可以是通过 await/promise 实现同步、异步的控制。
 *
 * 问题：应该生成什么结构的代码，标准是什么？
 * 最简单的方法是，即使碰到"并行"节点，也一路生成下去，知道当前的遍历遇到新的"等待"事件，就算结束。
 * "至于"前端的请求希望获得什么样的反馈，是"另一个问题"。
 *
 * 1. "并行开始"节点里的代码，怎么写？
 * - 并行后的代码节点实际上是一种示意？里面可能"动态化"。所以从并行开始到并行结束，应该是一起来写的？？？
 * - 分成两个互相不依赖，但是互相"可以知晓"的部分？
 * - 如果没有"并行结束"？，也是可以的。！
 * - 关于"动态化"的问题，实际上不只是并行节点，应该是每个响应块都要把后面动态化？？只不过因为我们有了
 * - 可以先不管。
 *
 *
 * 2. "并行结束"里的代码怎么写？
 * 3. "恢复上下文"怎么实现？
 *
 */

// 需要生成的代码

// TODO 1 等待的用户事件+往后遍历的响应逻辑
system.on.userAction(function makeFriend() {
  // TODO 1 判断到底是不是相应的 action
  // TODO 1.1 有分支的情况

  // TODO 2 响应片段(直接接在用户事件后面)
  // TODO 2.1 响应代码后面连接了分支、并行开始、并行结束

  // TODO 2.2 响应片段中触发的系统变更，可能又会有人监听，怎么"表达"，是直接生成到这里，还是用事件？？
  // 本质上这种关联应该是属于后者的，但是我们在"纵观全局"的时候也要"知晓"，因为"后者的逻辑是一种归纳"，
  // 有时候前者的变化会打破这种"归纳的规律"，所以应该能知晓，随时检查。


})

// TODO 2 系统变更事件：数据变化、系统调用等等
// TODO 3 系统定时器等其他触发


/**
 * 宏观的看生成代码的标准：
 * 1. 生成的代码要精良易于阅读、调试。这里的易于是指符合实现的。
 * 2. 上下文在一起，不要有中间跳转。
 */


/**
 * 需要
 */

