# 框架目标

以研发体验为中心。研发体验以"代码的可维护性"为指导指标。"代码的可维护性" 以 "是否正确按照当前角色的领域知识描述了需求" 为指导方法。
例如：框架既要承载写"业务代码"的能力，也要承载"组件库开发"的能力。这两者虽然能用同样的技术底层实现，但角色之间的目标其实是不同的，因此"需求描述也会不同"。

业务代码开发需求是"尽快"地实现业务，实际工作是一方面在描述自己的业务，一方面在使用已经有的基础设施，如组件库。
在描述业务时可能会有"领域模型"的概念，"业务组件"的概念，希望框架能支持好。
在使用基础设施时，希望"基础设施"刚好能覆盖到自己的需求，这就要求基础设施要足够灵活。

而写组件的需求是，最好能自动变得"灵活"，比如受控和非受控，能减少人工重复判断。
同时由于"灵活"，代码的 feature 变多后，对代码的"可读性性要求"、"稳定性要求"也会更高。

## 目前的具体目标

- 稳定性。任何角色都重要
  - 无内存泄露
  - 无框架逻辑错误
  
- 逻辑编写体验：
  - 业务逻辑
    - 错误提示
      - vnodeComputed 忘记写成函数
      - computed 数据忘记写成函数？？？
    - 能力
      - 数据 reactive
      - 数据 draft
      - "生命周期"？业务组件需要，加载时就获取数据。？？？
      - Layout
      - Style (需要用 createComponent)
      - 常用组件库/utilities
  - 组件逻辑
    - 错误提示
      - feature fragment/elements 写错，没有匹配？？？
      - arguments 不存在，写错？？？
    - 能力
      - Feature AOP(数据、样式、行为)
      - controlled/uncontrolled
      - Style 分离
      - listener preventDefault
      - runtime Feature AOP(数据、样式、行为)
        - 修改样式
        - 修改 局部使用的组件
        - 任意节点的 listener
        - 修改 listener 行为
- Debug 体验
  - 数据
   - 用户发现问题都是从界面上来的。然后开始复现。基本可以按照数据来源不同来分类调试难度。
     - 本地 ref/reactive。通过简单的 debugger 就能发现问题
     - 当前组件的 computed。
       - 需要知道依赖度的数据是不是有问题。
         - 数据需要有名字！！！
         - 在相应的 computed 里面写个 debugger??? 
           - 需要知道当前为什么变化？？？因为可能执行很多次？？？在 console.log 里面打印出来。
       - 需要知道计算过程是不是有问题。
         - 似乎只能通过 debugger 一步一步执行。？？？
  - 行为问题
     - 例如之前 focus 的问题，如果不知道就完全没法处理
     - 需要知道是"谁修改了数据"、"谁没有修改数据"。  
  - 样式
     - 也是数据的问题
     
  - Feature
     - 数据、样式、都有前置、后置的问题，需要单独考虑？？？？
  
  
思考一下，
1. 为什么 react 的形式没有类似问题？？？
因为 state/prop 都在"执行"的作用域里，在这个作用域里，既能看到所有的数据，又能通过 debugger 来看到计算的过程。

而在 AXII 中不是这样。
首先数据的依赖，是在数据的 computation function 里面实现的，并不能通过从上至下的顺序来看清。
其次，每个数据的计算过程都分散在各自的 computation 中，不能通过一次 debugger 发现所有问题。
这就使得，在一次 debugger 中"找到变化的最源头"的问题成了非常重要的需求！！！

2. "AXII 的重写是否有利于处理实现研发体验提升？？"
 - AXII 负责了组件的"生命周期"，而组件持有所有的 "computed"，所以组件是否正确回收了 computed 对稳定性有非常大的影响。
 - 组件负责了事件的来源。对开发者也来说"什么行为触发了"数据变化也很重要。这对"找到变化的最源头"很重要。
 - AXII 负责了见面的更新，只要界面更新不出问题，例如 diff，当出现问题时，能直接给出用户提示，那么就足够了。
 
结论：
- 数据变化的触发源头是最重要的。
- computed 是否被正确回收是最重要的。
- AXII 的渲染机制等梳理清楚可以帮助排除 AXII 的问题还是数据的问题。

 
 
 
