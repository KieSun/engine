# 框架目标

以研发体验为中心。研发体验以"代码的可维护性"为指导指标。"代码的可维护性" 以 "是否正确按照当前角色的领域知识描述了需求" 为指导方法。
例如：框架既要承载写"业务代码"的能力，也要承载"组件库开发"的能力。这两者虽然能用同样的技术底层实现，但角色之间的目标其实是不同的，因此"需求描述也会不同"。

业务代码开发需求是"尽快"地实现业务，实际工作是一方面在描述自己的业务，一方面在使用已经有的基础设施，如组件库。
在描述业务时可能会有"领域模型"的概念，"业务组件"的概念，希望框架能支持好。
在使用基础设施时，希望"基础设施"刚好能覆盖到自己的需求，这就要求基础设施要足够灵活。

而写组件的需求是，最好能自动变得"灵活"，比如受控和非受控，能减少人工重复判断。
同时由于"灵活"，代码的 feature 变多后，对代码的"可读性性要求"、"稳定性要求"也会更高。

## 目前的具体目标

- 稳定性。任何角色都重要
  - 无内存泄露
  - 无框架逻辑错误
  
- 逻辑编写体验：
  - 业务逻辑
    - 错误提示
      - vnodeComputed 忘记写成函数
      - computed 数据忘记写成函数？？？
    - 能力
      - 数据 reactive
      - 数据 draft
      - "生命周期"？业务组件需要，加载时就获取数据。？？？
      - Layout
      - Style (需要用 createComponent)
      - 常用组件库/utilities
  - 组件逻辑
    - 错误提示
      - feature fragment/elements 写错，没有匹配？？？
      - arguments 不存在，写错？？？
    - 能力
      - Feature AOP(数据、样式、行为)
      - controlled/uncontrolled
      - Style 分离
      - listener preventDefault
      - runtime Feature AOP(数据、样式、行为)
        - 修改样式
        - 修改 局部使用的组件
        - 任意节点的 listener
        - 修改 listener 行为
- Debug 体验
  - 数据
   - 用户发现问题都是从界面上来的。然后开始复现。基本可以按照数据来源不同来分类调试难度。
     - 本地 ref/reactive。通过简单的 debugger 就能发现问题
     - 当前组件的 computed。
       - 需要知道依赖度的数据是不是有问题。
         - 数据需要有名字！！！
         - 在相应的 computed 里面写个 debugger??? 
           - 需要知道当前为什么变化？？？因为可能执行很多次？？？在 console.log 里面打印出来。
       - 需要知道计算过程是不是有问题。
         - 似乎只能通过 debugger 一步一步执行。？？？
  - 行为问题
     - 例如之前 focus 的问题，如果不知道就完全没法处理
     - 需要知道是"谁修改了数据"、"谁没有修改数据"。  
  - 样式
     - 也是数据的问题
     
  - Feature
     - 数据、样式、都有前置、后置的问题，需要单独考虑？？？？
  
  
思考一下，
1. 为什么 react 的形式没有类似问题？？？
因为 state/prop 都在"执行"的作用域里，在这个作用域里，既能看到所有的数据，
 - 1. 哪个数据出错马上就可以看到，在同一个作用域内。
 - 2. 如果发现错误，可以在一次 debugger 内，就看到出错计算的过程，因为计算过程是线性的。
 - 3. debugger 触发的地方就可以看到计算发生了几次，是"谁"触发发生的。

而在 AXII/Reactive Data 系统中不是这样。
1. 数据不再同一个作用域内，无法一次看到。
2. 发现错误后，要重新找到依赖数据创建的地方，重新 debug。并且由于不是线性的，不能一路 debugger 回远点。
3. debugger 可以看到几次计算，但看不到是谁触发的。

重新思考 debug 这件事！为什么会写错。
 - 计算逻辑写错，最常见
 - 框架使用错误，应该尽量有框架提示
其核心在于：人还是最擅长线性思维，必须提供用户脑中符合"线性思维"的工具。例如在 reactive 的系统提供：
1. 触发条件
2. 数据、事件变化的先后顺序，并且最好可以不用手动，而是自动一步一步跳转。

找到 bug 还要和编辑器结合起来，方便直接修改。

 
结论：
- 数据变化的触发源头是最重要的。
- computed 是否被正确回收是最重要的。
- AXII 的渲染机制等梳理清楚可以帮助排除 AXII 的问题还是数据的问题。


 
 
